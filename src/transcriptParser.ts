import * as fs from "fs";
import * as path from "path";
import * as os from "os";

// Session status enum for distinguishing waiting states
export enum SessionStatus {
  WORKING = "working",  // Claude is actively using tools
  PAUSED = "paused",    // Claude asked a question, waiting for user input
  DONE = "done",        // Claude completed the task
}

// Constants
const LARGE_FILE_THRESHOLD_BYTES = 5 * 1024 * 1024; // 5MB - max file size for full parsing
const LARGE_FILE_CHUNK_SIZE_BYTES = 100 * 1024; // 100KB - chunk size for large file sampling
const USER_PROMPT_TRUNCATE_LENGTH = 100; // Max length for last user prompt display
const FIRST_MESSAGE_TRUNCATE_LENGTH = 50; // Max length for first user message display

/**
 * Derive the working directory from the project folder path.
 * Claude stores sessions in ~/.claude/projects/<encoded-path>/*.jsonl
 * where <encoded-path> is the cwd with '/' replaced by '-' and leading '-'
 * Example: -Users-billywu-claude-watch -> /Users/billywu/claude-watch
 */
function deriveCwdFromPath(filePath: string): string {
  // Extract project folder name from path like:
  // ~/.claude/projects/-Users-billywu-claude-watch/session.jsonl
  const projectsDir = path.join(os.homedir(), ".claude", "projects");
  if (!filePath.startsWith(projectsDir)) {
    return "";
  }
  const relativePath = filePath.slice(projectsDir.length + 1); // +1 for separator
  const projectFolder = relativePath.split(path.sep)[0];
  if (!projectFolder || !projectFolder.startsWith("-")) {
    return "";
  }
  // Convert "-Users-billywu-claude-watch" to "/Users/billywu/claude-watch"
  return projectFolder.replace(/-/g, "/");
}

// Model context window sizes
const MODEL_CONTEXT_WINDOWS: Record<string, number> = {
  "claude-opus-4-5-20251101": 200000,
  "claude-sonnet-4-20250514": 200000,
  "claude-3-5-sonnet-20241022": 200000,
  "claude-3-5-haiku-20241022": 200000,
  // Default fallback
  default: 200000,
};

// Token usage statistics
export interface TokenUsage {
  contextTokens: number; // total context (input + cache)
  maxContextTokens: number; // model's max context window
  inputTokens: number; // new input tokens (not cached)
  cacheReadTokens: number; // tokens read from cache
  cacheWriteTokens: number; // tokens written to cache
  outputTokens: number; // tokens generated by model
}

export interface SessionState {
  sessionId: string;
  slug: string;
  cwd: string;
  currentTask: string;
  inProgressTask: string;
  lastUserPrompt: string;
  firstUserMessage: string; // The first user message in the session
  summary: string; // Claude-generated summary of the session
  isWaiting: boolean;
  status: SessionStatus; // More granular: WORKING, PAUSED, or DONE
  lastModified: number;
  created: number;
  filePath: string;
  isAgent: boolean;
  parentSessionId: string | null;
  isCleared: boolean;
  hasRealActivity: boolean; // true if agent has non-warmup user messages or tasks
  // Token usage (kept for backwards compat)
  contextTokens: number;
  maxContextTokens: number;
  // Detailed token stats
  tokenUsage: TokenUsage;
  // Full todo list from last TodoWrite
  todos: TodoItem[];
}

interface TranscriptEntry {
  type: string;
  sessionId?: string;
  slug?: string;
  cwd?: string;
  agentId?: string;
  isSidechain?: boolean;
  summary?: string; // Claude-generated summary of the session
  message?: {
    role?: string;
    model?: string;
    content?: string | ContentItem[];
    usage?: {
      input_tokens?: number;
      cache_creation_input_tokens?: number;
      cache_read_input_tokens?: number;
      output_tokens?: number;
    };
  };
}

interface ContentItem {
  type: string;
  name?: string;
  text?: string; // For text content items
  input?: {
    todos?: TodoItem[];
  };
}

export interface TodoItem {
  content: string;
  status: string;
  activeForm?: string;  // Optional: "Running tests..." form
}

export function parseTranscript(filePath: string): SessionState | null {
  try {
    const stats = fs.statSync(filePath);

    let content: string;

    if (stats.size > LARGE_FILE_THRESHOLD_BYTES) {
      // For large files, read from start (for metadata) and end (for current state)
      // Issue 7: Re-stat the file after opening to get accurate size during active writes
      const fd = fs.openSync(filePath, "r");
      try {
        // Re-stat to get current size (file may have grown since initial stat)
        const currentStats = fs.fstatSync(fd);
        const currentSize = currentStats.size;

        // Read start for metadata (sessionId, cwd, etc.)
        const startBuffer = Buffer.alloc(LARGE_FILE_CHUNK_SIZE_BYTES);
        fs.readSync(fd, startBuffer, 0, LARGE_FILE_CHUNK_SIZE_BYTES, 0);

        // Read end for current state - use current size for accurate positioning
        const endBuffer = Buffer.alloc(LARGE_FILE_CHUNK_SIZE_BYTES);
        const endPosition = Math.max(0, currentSize - LARGE_FILE_CHUNK_SIZE_BYTES);
        fs.readSync(fd, endBuffer, 0, LARGE_FILE_CHUNK_SIZE_BYTES, endPosition);

        content = startBuffer.toString("utf-8") + "\n" + endBuffer.toString("utf-8");
      } finally {
        fs.closeSync(fd);
      }
    } else {
      content = fs.readFileSync(filePath, "utf-8");
    }

    const lines = content.trim().split("\n").filter((l) => l.trim());

    // Handle empty files - new sessions that haven't had activity yet
    if (lines.length === 0) {
      const fileName = path.basename(filePath, ".jsonl");
      const isAgent = fileName.startsWith("agent-");
      // Derive cwd from file path for new sessions that don't have it yet
      const derivedCwd = deriveCwdFromPath(filePath);
      const defaultTokenUsage: TokenUsage = {
        contextTokens: 0,
        maxContextTokens: MODEL_CONTEXT_WINDOWS.default,
        inputTokens: 0,
        cacheReadTokens: 0,
        cacheWriteTokens: 0,
        outputTokens: 0,
      };
      return {
        sessionId: fileName,
        slug: fileName.slice(0, 8),
        cwd: derivedCwd,
        currentTask: "Starting...",
        inProgressTask: "",
        lastUserPrompt: "",
        firstUserMessage: "",
        summary: "",
        isWaiting: true,
        status: SessionStatus.WORKING, // New session, considered working
        lastModified: stats.mtimeMs,
        created: stats.birthtimeMs,
        filePath,
        isAgent,
        parentSessionId: null,
        isCleared: false,
        hasRealActivity: false,
        contextTokens: 0,
        maxContextTokens: MODEL_CONTEXT_WINDOWS.default,
        tokenUsage: defaultTokenUsage,
        todos: [],
      };
    }

    let sessionId = "";
    let slug = "";
    let cwd = "";
    let firstUserMessage = "";
    let lastUserPrompt = "";
    let currentInProgressTask = "";
    let lastEntryType = "";
    let lastEntryIsToolUse = false;
    let agentId = "";
    let isAgent = false;
    let parentSessionId: string | null = null;
    let isCleared = false;
    let hasRealActivity = false; // Track if there's non-warmup user activity
    let contextTokens = 0;
    let inputTokens = 0;
    let cacheReadTokens = 0;
    let cacheWriteTokens = 0;
    let outputTokens = 0;
    let modelName = "";
    // Tracking for Paused vs Done detection
    let lastAssistantHasAskUserQuestion = false;
    let lastAssistantText = "";
    // Track full todo list from last TodoWrite
    let currentTodos: TodoItem[] = [];
    // Claude-generated summary of the session
    let summary = "";

    for (const line of lines) {
      try {
        const entry: TranscriptEntry = JSON.parse(line);

        // Extract session metadata from first entries
        if (entry.sessionId && !sessionId) {
          sessionId = entry.sessionId;
        }
        if (entry.slug && !slug) {
          slug = entry.slug;
        }
        if (entry.cwd && !cwd) {
          cwd = entry.cwd;
        }
        // Detect agent sessions
        if (entry.agentId && !agentId) {
          agentId = entry.agentId;
          isAgent = true;
          // For agents, sessionId is actually the parent's session ID
          // Fall back to already-captured sessionId if this entry doesn't have it
          parentSessionId = entry.sessionId || sessionId || null;
        }

        // Extract Claude-generated summary
        if (entry.type === "summary" && entry.summary) {
          summary = entry.summary;
        }

        // Track entry type for waiting state (assistant entries only here, user entries below)
        if (entry.type === "assistant") {
          lastEntryType = entry.type;
          lastEntryIsToolUse = false;
        }

        // Get user messages
        if (entry.type === "user" && entry.message?.content) {
          const content = entry.message.content;
          if (typeof content === "string") {
            // Check for /clear command (can appear in different XML formats)
            if (content.includes("/clear") && (
                content.includes("<command-name>") ||
                content.includes("<command-message>")
              )) {
              isCleared = true;
              // Reset first user message and last prompt since we're starting fresh
              firstUserMessage = "";
              lastUserPrompt = "";
              // Don't update lastEntryType for /clear - session is waiting for real input
            } else if (!content.includes("<command-name>") && !content.includes("<local-command-stdout>") && !content.includes("<command-message>")) {
              // Real user message (not a command) - session is no longer in "just cleared" state
              // Only reset isCleared if there's actual non-empty content
              const trimmedContent = content.trim();
              // Skip system-generated messages like context continuation notices
              const isSystemMessage = trimmedContent.startsWith("This session is being continued") ||
                trimmedContent.startsWith("<system-reminder>") ||
                trimmedContent.startsWith("Human:") ||
                trimmedContent.includes("ran out of context");
              if (trimmedContent && !isSystemMessage) {
                isCleared = false;
                // Only update last user prompt AND entry type for real user messages
                lastEntryType = "user";
                lastEntryIsToolUse = false;
                lastUserPrompt = content.slice(0, USER_PROMPT_TRUNCATE_LENGTH);
                if (content.length > USER_PROMPT_TRUNCATE_LENGTH) {
                  lastUserPrompt += "…";
                }
              }
            }
            // Command messages don't update lastEntryType - they don't affect waiting state
            // Only set first user message once (skip command messages, "Warmup" for agents, and system messages)
            const isWarmupMessage = content.trim() === "Warmup";
            const trimmed = content.trim();
            const isSystemMsg = trimmed.startsWith("This session is being continued") ||
              trimmed.startsWith("<system-reminder>") ||
              trimmed.startsWith("Human:") ||
              trimmed.includes("ran out of context");
            if (!firstUserMessage && !content.includes("<command-name>") && !content.includes("<local-command-stdout>") && !isWarmupMessage && !isSystemMsg) {
              firstUserMessage = content.slice(0, FIRST_MESSAGE_TRUNCATE_LENGTH);
              if (content.length > FIRST_MESSAGE_TRUNCATE_LENGTH) {
                firstUserMessage += "…";
              }
              hasRealActivity = true; // Found a real user message
            }
          }
        }

        // Look for tool calls to track activity and current task
        if (entry.type === "assistant" && entry.message?.content) {
          const content = entry.message.content;
          // Reset tracking for each new assistant message
          lastAssistantHasAskUserQuestion = false;
          lastAssistantText = "";

          if (Array.isArray(content)) {
            for (const item of content) {
              if (item.type === "tool_use") {
                lastEntryIsToolUse = true;
                hasRealActivity = true; // Any tool use means real activity
                // Track AskUserQuestion for Paused detection
                if (item.name === "AskUserQuestion") {
                  lastAssistantHasAskUserQuestion = true;
                }
                if (item.name === "TodoWrite" && item.input?.todos) {
                  // Store full todo list
                  currentTodos = item.input.todos;
                  // Find in_progress task
                  const inProgress = item.input.todos.find(
                    (t) => t.status === "in_progress"
                  );
                  if (inProgress) {
                    currentInProgressTask = inProgress.content;
                  }
                }
              } else if (item.type === "text" && item.text) {
                // Capture text content for question detection
                lastAssistantText = item.text;
              }
            }
          }

          // Extract token usage from assistant messages
          if (entry.message.usage) {
            const usage = entry.message.usage;
            inputTokens = usage.input_tokens || 0;
            cacheReadTokens = usage.cache_read_input_tokens || 0;
            cacheWriteTokens = usage.cache_creation_input_tokens || 0;
            outputTokens = usage.output_tokens || 0;
            // Total context = input_tokens + cache tokens (both creation and read)
            contextTokens = inputTokens + cacheWriteTokens + cacheReadTokens;
          }

          // Track model name for context window size
          if (entry.message.model) {
            modelName = entry.message.model;
          }
        }
      } catch (error) {
        // Skip malformed lines
        console.warn('Failed to parse transcript line:', error);
        continue;
      }
    }

    // Determine if waiting for user input
    // Waiting = last entry is assistant AND not a tool use (Claude finished speaking)
    // Also waiting if session was just cleared (no real user message yet)
    // Also waiting if no user/assistant entries found (empty or metadata-only session)
    const isWaiting = isCleared || lastEntryType === "" || (lastEntryType === "assistant" && !lastEntryIsToolUse);

    // Determine session status (more granular than isWaiting)
    let status: SessionStatus;
    if (!isWaiting) {
      status = SessionStatus.WORKING;
    } else if (lastAssistantHasAskUserQuestion || lastAssistantText.trimEnd().endsWith("?")) {
      // Claude asked a question - waiting for user input
      status = SessionStatus.PAUSED;
    } else {
      // Claude finished without asking - task is done
      status = SessionStatus.DONE;
    }

    // Use in-progress task if available, otherwise first user message
    // For agents without a meaningful task, show "Exploring..." since they're typically exploring the codebase
    const defaultTask = isAgent ? "Exploring..." : "New session";
    const currentTask = currentInProgressTask || firstUserMessage || defaultTask;

    // For agent sessions, use agentId as the identifier
    const effectiveSessionId = isAgent ? agentId : sessionId;

    // Fallback: derive cwd from file path if not found in transcript
    const effectiveCwd = cwd || deriveCwdFromPath(filePath);

    // Get max context window for the model
    const maxContextTokens = MODEL_CONTEXT_WINDOWS[modelName] || MODEL_CONTEXT_WINDOWS.default;

    // Build token usage object
    const tokenUsage: TokenUsage = {
      contextTokens,
      maxContextTokens,
      inputTokens,
      cacheReadTokens,
      cacheWriteTokens,
      outputTokens,
    };

    return {
      sessionId: effectiveSessionId,
      slug: slug || effectiveSessionId.slice(0, 8),
      cwd: effectiveCwd,
      currentTask,
      inProgressTask: currentInProgressTask,
      lastUserPrompt,
      firstUserMessage,
      summary,
      isWaiting,
      status,
      lastModified: stats.mtimeMs,
      created: stats.birthtimeMs,
      filePath,
      isAgent,
      parentSessionId,
      isCleared,
      hasRealActivity,
      contextTokens,
      maxContextTokens,
      tokenUsage,
      todos: currentTodos,
    };
  } catch (error) {
    console.error('Failed to parse transcript file:', error);
    return null;
  }
}

