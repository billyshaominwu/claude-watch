import * as fs from "fs";
import * as path from "path";
import * as os from "os";

// Session status enum for distinguishing waiting states
export enum SessionStatus {
  WORKING = "working",  // Claude is actively using tools
  PAUSED = "paused",    // Claude asked a question, waiting for user input
  DONE = "done",        // Claude completed the task
}

// Constants
const LARGE_FILE_THRESHOLD_BYTES = 5 * 1024 * 1024; // 5MB - max file size for full parsing
const LARGE_FILE_CHUNK_SIZE_BYTES = 100 * 1024; // 100KB - chunk size for large file sampling
const USER_PROMPT_TRUNCATE_LENGTH = 100; // Max length for last user prompt display
const FIRST_MESSAGE_TRUNCATE_LENGTH = 50; // Max length for first user message display

/**
 * Derive the working directory from the project folder path.
 * Claude stores sessions in ~/.claude/projects/<encoded-path>/*.jsonl
 * where <encoded-path> is the cwd with '/' replaced by '-'
 *
 * The tricky part: paths containing hyphens (like /Users/foo/my-project)
 * become ambiguous when encoded (-Users-foo-my-project).
 * We can't know if "my-project" was one segment or two.
 *
 * Strategy: Return the folder name as-is (encoded form) and let the caller
 * match against known CWDs using encodePathForClaude().
 */
function deriveCwdFromPath(filePath: string): string {
  // Extract project folder name from path like:
  // ~/.claude/projects/-Users-billywu-claude-watch/session.jsonl
  const projectsDir = path.join(os.homedir(), ".claude", "projects");
  if (!filePath.startsWith(projectsDir)) {
    return "";
  }
  const relativePath = filePath.slice(projectsDir.length + 1); // +1 for separator
  const projectFolder = relativePath.split(path.sep)[0];
  if (!projectFolder || !projectFolder.startsWith("-")) {
    return "";
  }

  // Naive decode: replace all '-' with '/'
  // This works for paths without hyphens in directory names
  const naiveDecode = projectFolder.replace(/-/g, "/");

  // Check if the path exists - if so, use it
  try {
    if (fs.existsSync(naiveDecode)) {
      return naiveDecode;
    }
  } catch {
    // Ignore errors
  }

  // If naive decode doesn't exist, try to find a valid path by checking
  // different hyphen placements. Start from the end (most likely location for project name hyphens)
  const parts = projectFolder.slice(1).split("-"); // Remove leading "-", split on "-"

  // Try progressively merging parts from the end with hyphens
  // e.g., for ["Users", "foo", "my", "project"], try:
  //   /Users/foo/my-project, /Users/foo-my/project, etc.
  for (let mergePoint = parts.length - 1; mergePoint >= 1; mergePoint--) {
    const pathParts = [
      ...parts.slice(0, mergePoint),
      parts.slice(mergePoint).join("-")
    ];
    const candidate = "/" + pathParts.join("/");
    try {
      if (fs.existsSync(candidate)) {
        return candidate;
      }
    } catch {
      // Ignore errors
    }
  }

  // Fallback to naive decode
  return naiveDecode;
}

// Model context window sizes
const MODEL_CONTEXT_WINDOWS: Record<string, number> = {
  "claude-opus-4-5-20251101": 200000,
  "claude-sonnet-4-20250514": 200000,
  "claude-3-5-sonnet-20241022": 200000,
  "claude-3-5-haiku-20241022": 200000,
  // Default fallback
  default: 200000,
};

// Token usage statistics
export interface TokenUsage {
  contextTokens: number; // total context (input + cache)
  maxContextTokens: number; // model's max context window
  inputTokens: number; // new input tokens (not cached)
  cacheReadTokens: number; // tokens read from cache
  cacheWriteTokens: number; // tokens written to cache
  outputTokens: number; // tokens generated by model (last message)
  totalOutputTokens: number; // accumulated output tokens across all messages
}

export interface SessionState {
  sessionId: string;
  slug: string;
  cwd: string;
  inProgressTask: string;
  lastUserPrompt: string;
  firstUserMessage: string;
  summary: string;
  status: SessionStatus;
  lastModified: number;
  created: number;
  filePath: string;
  isAgent: boolean;
  parentSessionId: string | null;
  tokenUsage: TokenUsage;
  todos: TodoItem[];
}

interface TranscriptEntry {
  type: string;
  sessionId?: string;
  slug?: string;
  cwd?: string;
  agentId?: string;
  summary?: string;
  message?: {
    role?: string;
    model?: string;
    content?: string | ContentItem[];
    usage?: {
      input_tokens?: number;
      cache_creation_input_tokens?: number;
      cache_read_input_tokens?: number;
      output_tokens?: number;
    };
  };
}

interface ContentItem {
  type: string;
  name?: string;
  text?: string; // For text content items
  input?: {
    todos?: TodoItem[];
  };
}

export interface TodoItem {
  content: string;
  status: string;
}

export function parseTranscript(filePath: string): SessionState | null {
  try {
    const stats = fs.statSync(filePath);

    let content: string;

    if (stats.size > LARGE_FILE_THRESHOLD_BYTES) {
      // For large files, read from start (for metadata) and end (for current state)
      // Issue 7: Re-stat the file after opening to get accurate size during active writes
      const fd = fs.openSync(filePath, "r");
      try {
        // Re-stat to get current size (file may have grown since initial stat)
        const currentStats = fs.fstatSync(fd);
        const currentSize = currentStats.size;

        // Read start for metadata (sessionId, cwd, etc.)
        const startBuffer = Buffer.alloc(LARGE_FILE_CHUNK_SIZE_BYTES);
        fs.readSync(fd, startBuffer, 0, LARGE_FILE_CHUNK_SIZE_BYTES, 0);

        // Read end for current state - use current size for accurate positioning
        const endBuffer = Buffer.alloc(LARGE_FILE_CHUNK_SIZE_BYTES);
        const endPosition = Math.max(0, currentSize - LARGE_FILE_CHUNK_SIZE_BYTES);
        fs.readSync(fd, endBuffer, 0, LARGE_FILE_CHUNK_SIZE_BYTES, endPosition);

        content = startBuffer.toString("utf-8") + "\n" + endBuffer.toString("utf-8");
      } finally {
        fs.closeSync(fd);
      }
    } else {
      content = fs.readFileSync(filePath, "utf-8");
    }

    const lines = content.trim().split("\n").filter((l) => l.trim());

    // Handle empty files - new sessions that haven't had activity yet
    if (lines.length === 0) {
      const fileName = path.basename(filePath, ".jsonl");
      const isAgent = fileName.startsWith("agent-");
      const derivedCwd = deriveCwdFromPath(filePath);
      const defaultTokenUsage: TokenUsage = {
        contextTokens: 0,
        maxContextTokens: MODEL_CONTEXT_WINDOWS.default,
        inputTokens: 0,
        cacheReadTokens: 0,
        cacheWriteTokens: 0,
        outputTokens: 0,
        totalOutputTokens: 0,
      };
      return {
        sessionId: fileName,
        slug: fileName.slice(0, 8),
        cwd: derivedCwd,
        inProgressTask: "",
        lastUserPrompt: "",
        firstUserMessage: "",
        summary: "",
        status: SessionStatus.DONE,
        lastModified: stats.mtimeMs,
        created: stats.birthtimeMs,
        filePath,
        isAgent,
        parentSessionId: null,
        tokenUsage: defaultTokenUsage,
        todos: [],
      };
    }

    let sessionId = "";
    let slug = "";
    let cwd = "";
    let firstUserMessage = "";
    let lastUserPrompt = "";
    let currentInProgressTask = "";
    let lastEntryType = "";
    let lastEntryIsToolUse = false;
    let agentId = "";
    let isAgent = false;
    let parentSessionId: string | null = null;
    let isCleared = false;
    let contextTokens = 0;
    let inputTokens = 0;
    let cacheReadTokens = 0;
    let cacheWriteTokens = 0;
    let outputTokens = 0;
    let totalOutputTokens = 0;
    let modelName = "";
    // Tracking for Paused vs Done detection
    let lastAssistantHasAskUserQuestion = false;
    let lastAssistantText = "";
    // Track full todo list from last TodoWrite
    let currentTodos: TodoItem[] = [];
    // Claude-generated summary of the session
    let summary = "";
    // Track if summary was found before or after user activity
    // Summary from previous context appears before user messages and should be ignored
    let foundUserActivity = false;
    let summaryIsFromPreviousContext = false;

    for (const line of lines) {
      try {
        const entry: TranscriptEntry = JSON.parse(line);

        // Extract session metadata from first entries
        if (entry.sessionId && !sessionId) {
          sessionId = entry.sessionId;
        }
        if (entry.slug && !slug) {
          slug = entry.slug;
        }
        if (entry.cwd && !cwd) {
          cwd = entry.cwd;
        }
        // Detect agent sessions
        if (entry.agentId && !agentId) {
          agentId = entry.agentId;
          isAgent = true;
          // For agents, sessionId is actually the parent's session ID
          // Fall back to already-captured sessionId if this entry doesn't have it
          parentSessionId = entry.sessionId || sessionId || null;
        }

        // Extract Claude-generated summary
        // Only use summary if it appears AFTER user activity in the transcript
        // Summaries from previous context continuation appear at the start (before user messages)
        // and reflect the OLD session, not the current one
        if (entry.type === "summary" && entry.summary) {
          if (foundUserActivity) {
            // This summary was generated after user activity - it's valid
            summary = entry.summary;
            summaryIsFromPreviousContext = false;
          } else {
            // This summary appeared before any user messages - likely from previous context
            // Store it but mark it as from previous context
            summary = entry.summary;
            summaryIsFromPreviousContext = true;
          }
        }

        // Track entry type for waiting state (assistant entries only here, user entries below)
        if (entry.type === "assistant") {
          lastEntryType = entry.type;
          lastEntryIsToolUse = false;
        }

        // Get user messages
        if (entry.type === "user" && entry.message?.content) {
          const content = entry.message.content;
          if (typeof content === "string") {
            // Check for /clear command (can appear in different XML formats)
            if (content.includes("/clear") && (
                content.includes("<command-name>") ||
                content.includes("<command-message>")
              )) {
              isCleared = true;
              // Reset first user message and last prompt since we're starting fresh
              firstUserMessage = "";
              lastUserPrompt = "";
              // Don't update lastEntryType for /clear - session is waiting for real input
            } else if (!content.includes("<command-name>") && !content.includes("<local-command-stdout>") && !content.includes("<command-message>")) {
              // Real user message (not a command) - session is no longer in "just cleared" state
              // Only reset isCleared if there's actual non-empty content
              const trimmedContent = content.trim();
              // Skip system-generated messages like context continuation notices
              const isSystemMessage = trimmedContent.startsWith("This session is being continued") ||
                trimmedContent.startsWith("<system-reminder>") ||
                trimmedContent.startsWith("Human:") ||
                trimmedContent.includes("ran out of context");
              if (trimmedContent && !isSystemMessage) {
                isCleared = false;
                // Only update last user prompt AND entry type for real user messages
                lastEntryType = "user";
                lastEntryIsToolUse = false;
                lastUserPrompt = content.slice(0, USER_PROMPT_TRUNCATE_LENGTH);
                if (content.length > USER_PROMPT_TRUNCATE_LENGTH) {
                  lastUserPrompt += "…";
                }
                foundUserActivity = true; // Mark that we've seen user activity for summary tracking
              }
            }
            // Command messages don't update lastEntryType - they don't affect waiting state
            // Only set first user message once (skip command messages, "Warmup" for agents, and system messages)
            const isWarmupMessage = content.trim() === "Warmup";
            const trimmed = content.trim();
            const isSystemMsg = trimmed.startsWith("This session is being continued") ||
              trimmed.startsWith("<system-reminder>") ||
              trimmed.startsWith("Human:") ||
              trimmed.includes("ran out of context");
            if (!firstUserMessage && !content.includes("<command-name>") && !content.includes("<local-command-stdout>") && !isWarmupMessage && !isSystemMsg) {
              firstUserMessage = content.slice(0, FIRST_MESSAGE_TRUNCATE_LENGTH);
              if (content.length > FIRST_MESSAGE_TRUNCATE_LENGTH) {
                firstUserMessage += "…";
              }
              foundUserActivity = true;
            }
          }
        }

        // Look for tool calls to track activity and current task
        if (entry.type === "assistant" && entry.message?.content) {
          const content = entry.message.content;
          // Reset tracking for each new assistant message
          lastAssistantHasAskUserQuestion = false;
          lastAssistantText = "";

          if (Array.isArray(content)) {
            for (const item of content) {
              if (item.type === "tool_use") {
                lastEntryIsToolUse = true;
                // Track AskUserQuestion for Paused detection
                if (item.name === "AskUserQuestion") {
                  lastAssistantHasAskUserQuestion = true;
                }
                if (item.name === "TodoWrite" && item.input?.todos) {
                  // Store full todo list
                  currentTodos = item.input.todos;
                  // Find in_progress task
                  const inProgress = item.input.todos.find(
                    (t) => t.status === "in_progress"
                  );
                  if (inProgress) {
                    currentInProgressTask = inProgress.content;
                  }
                }
              } else if (item.type === "text" && item.text) {
                // Capture text content for question detection
                lastAssistantText = item.text;
              }
            }
          }

          // Extract token usage from assistant messages
          if (entry.message.usage) {
            const usage = entry.message.usage;
            inputTokens = usage.input_tokens || 0;
            cacheReadTokens = usage.cache_read_input_tokens || 0;
            cacheWriteTokens = usage.cache_creation_input_tokens || 0;
            outputTokens = usage.output_tokens || 0;
            totalOutputTokens += usage.output_tokens || 0;
            // Total context = input_tokens + cache tokens (both creation and read)
            contextTokens = inputTokens + cacheWriteTokens + cacheReadTokens;
          }

          // Track model name for context window size
          if (entry.message.model) {
            modelName = entry.message.model;
          }
        }
      } catch (error) {
        // Skip malformed lines
        console.warn('Failed to parse transcript line:', error);
        continue;
      }
    }

    // Determine session status based on last entry type
    const isWaitingForInput = isCleared || lastEntryType === "" || (lastEntryType === "assistant" && !lastEntryIsToolUse);
    let status: SessionStatus;
    if (!isWaitingForInput) {
      status = SessionStatus.WORKING;
    } else if (lastAssistantHasAskUserQuestion || lastAssistantText.trimEnd().endsWith("?")) {
      status = SessionStatus.PAUSED;
    } else {
      status = SessionStatus.DONE;
    }

    // For agent sessions, use agentId as the identifier
    const effectiveSessionId = isAgent ? agentId : sessionId;

    // Fallback: derive cwd from file path if not found in transcript
    const effectiveCwd = cwd || deriveCwdFromPath(filePath);

    // Get max context window for the model
    const maxContextTokens = MODEL_CONTEXT_WINDOWS[modelName] || MODEL_CONTEXT_WINDOWS.default;

    // Build token usage object
    const tokenUsage: TokenUsage = {
      contextTokens,
      maxContextTokens,
      inputTokens,
      cacheReadTokens,
      cacheWriteTokens,
      outputTokens,
      totalOutputTokens,
    };

    return {
      sessionId: effectiveSessionId,
      slug: slug || effectiveSessionId.slice(0, 8),
      cwd: effectiveCwd,
      inProgressTask: currentInProgressTask,
      lastUserPrompt,
      firstUserMessage,
      summary: summaryIsFromPreviousContext ? "" : summary,
      status,
      lastModified: stats.mtimeMs,
      created: stats.birthtimeMs,
      filePath,
      isAgent,
      parentSessionId,
      tokenUsage,
      todos: currentTodos,
    };
  } catch (error) {
    console.error('Failed to parse transcript file:', error);
    return null;
  }
}

