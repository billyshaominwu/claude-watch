import * as fs from "fs";
import * as path from "path";
import * as os from "os";

const HOOK_SCRIPT_NAME = "claude-watch.sh";

/**
 * The hook script that Claude Code will execute.
 * Captures PID/PPID/TTY directly from the Claude process and sends to VS Code.
 */
const HOOK_SCRIPT = `#!/bin/bash
# Claude Watch hook - captures session identity and sends to VS Code extension
# Auto-generated by Claude Watch VS Code extension

INPUT=$(cat)
EVENT=$(echo "$INPUT" | jq -r '.hook_event_name // empty')
SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // empty')
TRANSCRIPT=$(echo "$INPUT" | jq -r '.transcript_path // empty')
CWD=$(echo "$INPUT" | jq -r '.cwd // empty')

# Skip if missing required fields
if [ -z "$EVENT" ] || [ -z "$SESSION_ID" ]; then
  exit 0
fi

# Capture process identity (THE KEY DATA)
# Hook script is child of Claude, so:
#   $$ = hook script PID
#   $PPID = Claude's PID
#   We need Claude's PPID = terminal shell PID (for VS Code terminal matching)
CLAUDE_PID=$PPID
TERMINAL_PID=$(ps -o ppid= -p $CLAUDE_PID 2>/dev/null | tr -d ' ')
TTY_VAL=$(tty 2>/dev/null) || TTY_VAL="none"

# Build JSON message using jq for proper escaping (-c for compact single-line output)
# pid = Claude's PID, ppid = terminal shell PID (for VS Code matching)
MSG=$(jq -c -n \\
  --arg event "$EVENT" \\
  --arg sessionId "$SESSION_ID" \\
  --arg transcriptPath "$TRANSCRIPT" \\
  --arg cwd "$CWD" \\
  --argjson pid "$CLAUDE_PID" \\
  --argjson ppid "\${TERMINAL_PID:-0}" \\
  --arg tty "$TTY_VAL" \\
  '{event: $event, sessionId: $sessionId, transcriptPath: $transcriptPath, cwd: $cwd, pid: $pid, ppid: $ppid, tty: $tty}')

# Send to VS Code extension (cross-platform: works on macOS and Linux)
PORT=$(cat ~/.claude/.claude-watch-port 2>/dev/null || echo 9847)
(echo "$MSG" | nc -w 1 localhost $PORT 2>/dev/null) &
`;

/**
 * Configure Claude Code hooks for the extension.
 * Creates the hook script and updates settings.json.
 */
export async function configureHooks(): Promise<{ success: boolean; error?: string }> {
  try {
    const claudeDir = path.join(os.homedir(), ".claude");
    const hooksDir = path.join(claudeDir, "hooks");
    const settingsPath = path.join(claudeDir, "settings.json");
    const hookScriptPath = path.join(hooksDir, HOOK_SCRIPT_NAME);

    // Ensure directories exist
    if (!fs.existsSync(claudeDir)) {
      fs.mkdirSync(claudeDir, { recursive: true });
    }
    if (!fs.existsSync(hooksDir)) {
      fs.mkdirSync(hooksDir, { recursive: true });
    }

    // Write hook script
    fs.writeFileSync(hookScriptPath, HOOK_SCRIPT, { mode: 0o755 });
    console.log(`Claude Watch: Wrote hook script to ${hookScriptPath}`);

    // Read existing settings or create new
    let settings: Record<string, unknown> = {};
    if (fs.existsSync(settingsPath)) {
      try {
        const content = fs.readFileSync(settingsPath, "utf-8");
        settings = JSON.parse(content);
      } catch {
        // If settings file is corrupted, start fresh
        console.warn("Claude Watch: Could not parse existing settings.json, creating new");
      }
    }

    // Ensure hooks section exists
    if (!settings.hooks || typeof settings.hooks !== "object") {
      settings.hooks = {};
    }
    const hooks = settings.hooks as Record<string, unknown>;

    // Add our hook to SessionStart and SessionEnd
    // Format for lifecycle hooks (no matcher needed): { "hooks": [{ "type": "command", "command": "..." }] }
    const hookEntry = {
      hooks: [
        {
          type: "command",
          command: hookScriptPath,
        },
      ],
    };

    for (const event of ["SessionStart", "SessionEnd"]) {
      let eventHooks = hooks[event];

      if (!Array.isArray(eventHooks)) {
        eventHooks = [];
      }

      // Check if our hook is already registered (by command path)
      const hookArray = eventHooks as Array<{ hooks?: Array<{ type?: string; command?: string }> }>;
      const alreadyRegistered = hookArray.some(
        (h) => h.hooks?.some((inner) => inner.command === hookScriptPath)
      );

      if (!alreadyRegistered) {
        hookArray.push(hookEntry);
      }

      hooks[event] = hookArray;
    }

    // Write updated settings
    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
    console.log(`Claude Watch: Updated settings.json with hook configuration`);

    return { success: true };
  } catch (err) {
    const error = err instanceof Error ? err.message : String(err);
    console.error("Claude Watch: Failed to configure hooks:", error);
    return { success: false, error };
  }
}

/**
 * Check if hooks are already configured
 */
export function areHooksConfigured(): boolean {
  try {
    const claudeDir = path.join(os.homedir(), ".claude");
    const hooksDir = path.join(claudeDir, "hooks");
    const settingsPath = path.join(claudeDir, "settings.json");
    const hookScriptPath = path.join(hooksDir, HOOK_SCRIPT_NAME);

    // Check if script exists
    if (!fs.existsSync(hookScriptPath)) {
      return false;
    }

    // Check if settings reference our hook
    if (!fs.existsSync(settingsPath)) {
      return false;
    }

    const content = fs.readFileSync(settingsPath, "utf-8");
    const settings = JSON.parse(content);

    if (!settings.hooks) {
      return false;
    }

    const hooks = settings.hooks as Record<string, unknown>;

    // Check both events
    for (const event of ["SessionStart", "SessionEnd"]) {
      const eventHooks = hooks[event];
      if (!Array.isArray(eventHooks)) {
        return false;
      }

      // Check if our hook is registered (by command path)
      const hookArray = eventHooks as Array<{ hooks?: Array<{ type?: string; command?: string }> }>;
      const hasOurHook = hookArray.some(
        (h) => h.hooks?.some((inner) => inner.command === hookScriptPath)
      );

      if (!hasOurHook) {
        return false;
      }
    }

    return true;
  } catch {
    return false;
  }
}

