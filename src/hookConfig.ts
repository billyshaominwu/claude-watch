import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import * as vscode from "vscode";

function debugLog(message: string): void {
  if (vscode.workspace.getConfiguration('claudeWatch').get<boolean>('debug', false)) {
    console.log(`Claude Watch: ${message}`);
  }
}

const HOOK_SCRIPT_NAME = "claude-watch.sh";
const HOOK_SCRIPT_VERSION = "5"; // Increment when hook script changes - v5 fixes jq path for macOS

/**
 * The hook script that Claude Code will execute.
 * Captures PID/PPID/TTY directly from the Claude process and sends to VS Code.
 */
const HOOK_SCRIPT = `#!/bin/bash
# Claude Watch hook - captures session identity and tool activity, sends to VS Code extension
# Auto-generated by Claude Watch VS Code extension
# VERSION: ${HOOK_SCRIPT_VERSION}

INPUT=$(cat)
EVENT=$(echo "$INPUT" | jq -r '.hook_event_name // empty')
SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // empty')
TRANSCRIPT=$(echo "$INPUT" | jq -r '.transcript_path // empty')
CWD=$(echo "$INPUT" | jq -r '.cwd // empty')

# Skip if missing required fields
if [ -z "$EVENT" ] || [ -z "$SESSION_ID" ]; then
  exit 0
fi

# Capture process identity (THE KEY DATA)
# Hook script is child of Claude, so:
#   $$ = hook script PID
#   $PPID = Claude's PID
#   We need Claude's PPID = terminal shell PID (for VS Code terminal matching)
CLAUDE_PID=$PPID
TERMINAL_PID=$(/bin/ps -o ppid= -p $CLAUDE_PID 2>/dev/null | /usr/bin/tr -d ' ')
TTY_VAL=$(/usr/bin/tty 2>/dev/null) || TTY_VAL="none"

# Build JSON message based on event type
if [ "$EVENT" = "PreToolUse" ] || [ "$EVENT" = "PostToolUse" ]; then
  # Tool hooks - extract tool info
  TOOL_NAME=$(echo "$INPUT" | jq -r '.tool_name // empty')
  TOOL_INPUT=$(echo "$INPUT" | jq -c '.tool_input // {}')
  TOOL_RESULT=$(echo "$INPUT" | jq -c '.tool_result // null')
  TIMESTAMP=$(/bin/date +%s)000

  MSG=$(jq -c -n \\
    --arg event "$EVENT" \\
    --arg sessionId "$SESSION_ID" \\
    --arg transcriptPath "$TRANSCRIPT" \\
    --arg cwd "$CWD" \\
    --arg toolName "$TOOL_NAME" \\
    --argjson toolInput "$TOOL_INPUT" \\
    --argjson toolResult "$TOOL_RESULT" \\
    --argjson timestamp "$TIMESTAMP" \\
    --argjson pid "$CLAUDE_PID" \\
    --argjson ppid "\${TERMINAL_PID:-0}" \\
    --arg tty "$TTY_VAL" \\
    '{event: $event, sessionId: $sessionId, transcriptPath: $transcriptPath, cwd: $cwd, toolName: $toolName, toolInput: $toolInput, toolResult: $toolResult, timestamp: $timestamp, pid: $pid, ppid: $ppid, tty: $tty}')
else
  # Session hooks (SessionStart, SessionEnd)
  MSG=$(jq -c -n \\
    --arg event "$EVENT" \\
    --arg sessionId "$SESSION_ID" \\
    --arg transcriptPath "$TRANSCRIPT" \\
    --arg cwd "$CWD" \\
    --argjson pid "$CLAUDE_PID" \\
    --argjson ppid "\${TERMINAL_PID:-0}" \\
    --arg tty "$TTY_VAL" \\
    '{event: $event, sessionId: $sessionId, transcriptPath: $transcriptPath, cwd: $cwd, pid: $pid, ppid: $ppid, tty: $tty}')
fi

# Send to all registered VS Code instances (supports multiple workspaces)
PORT_FILE=~/.claude/.claude-watch-port
if [ -f "$PORT_FILE" ]; then
  while IFS= read -r PORT || [ -n "$PORT" ]; do
    if [ -n "$PORT" ]; then
      (echo "$MSG" | /usr/bin/nc -w 1 localhost $PORT 2>/dev/null) &
    fi
  done < "$PORT_FILE"
fi
`;

/**
 * Configure Claude Code hooks for the extension.
 * Creates the hook script and updates settings.json.
 */
export async function configureHooks(): Promise<{ success: boolean; error?: string }> {
  try {
    const claudeDir = path.join(os.homedir(), ".claude");
    const hooksDir = path.join(claudeDir, "hooks");
    const settingsPath = path.join(claudeDir, "settings.json");
    const hookScriptPath = path.join(hooksDir, HOOK_SCRIPT_NAME);

    // Ensure directories exist
    if (!fs.existsSync(claudeDir)) {
      fs.mkdirSync(claudeDir, { recursive: true });
    }
    if (!fs.existsSync(hooksDir)) {
      fs.mkdirSync(hooksDir, { recursive: true });
    }

    // Write hook script
    fs.writeFileSync(hookScriptPath, HOOK_SCRIPT, { mode: 0o755 });
    debugLog(`Wrote hook script to ${hookScriptPath}`);

    // Read existing settings or create new
    let settings: Record<string, unknown> = {};
    if (fs.existsSync(settingsPath)) {
      try {
        const content = fs.readFileSync(settingsPath, "utf-8");
        settings = JSON.parse(content);
      } catch {
        // If settings file is corrupted, start fresh
        console.warn("Claude Watch: Could not parse existing settings.json, creating new");
      }
    }

    // Ensure hooks section exists
    if (!settings.hooks || typeof settings.hooks !== "object") {
      settings.hooks = {};
    }
    const hooks = settings.hooks as Record<string, unknown>;

    // Add our hook to SessionStart and SessionEnd
    // Format for lifecycle hooks (no matcher needed): { "hooks": [{ "type": "command", "command": "..." }] }
    const lifecycleHookEntry = {
      hooks: [
        {
          type: "command",
          command: hookScriptPath,
        },
      ],
    };

    for (const event of ["SessionStart", "SessionEnd"]) {
      let eventHooks = hooks[event];

      if (!Array.isArray(eventHooks)) {
        eventHooks = [];
      }

      // Check if our hook is already registered (by command path)
      const hookArray = eventHooks as Array<{ hooks?: Array<{ type?: string; command?: string }> }>;
      const alreadyRegistered = hookArray.some(
        (h) => h.hooks?.some((inner) => inner.command === hookScriptPath)
      );

      if (!alreadyRegistered) {
        hookArray.push(lifecycleHookEntry);
      }

      hooks[event] = hookArray;
    }

    // Add our hook to PreToolUse and PostToolUse
    // Format for tool hooks (requires matcher): { "matcher": "...", "hooks": [{ "type": "command", "command": "..." }] }
    const toolHookEntry = {
      matcher: "*", // Match all tools
      hooks: [
        {
          type: "command",
          command: hookScriptPath,
        },
      ],
    };

    for (const event of ["PreToolUse", "PostToolUse"]) {
      let eventHooks = hooks[event];

      if (!Array.isArray(eventHooks)) {
        eventHooks = [];
      }

      // Check if our hook is already registered (by command path)
      const hookArray = eventHooks as Array<{ matcher?: string; hooks?: Array<{ type?: string; command?: string }> }>;
      const alreadyRegistered = hookArray.some(
        (h) => h.hooks?.some((inner) => inner.command === hookScriptPath)
      );

      if (!alreadyRegistered) {
        hookArray.push(toolHookEntry);
      }

      hooks[event] = hookArray;
    }

    // Write updated settings
    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
    debugLog(`Updated settings.json with hook configuration`);

    return { success: true };
  } catch (err) {
    const error = err instanceof Error ? err.message : String(err);
    console.error("Claude Watch: Failed to configure hooks:", error);
    return { success: false, error };
  }
}

/**
 * Check if hooks are already configured and up to date
 */
export function areHooksConfigured(): boolean {
  try {
    const claudeDir = path.join(os.homedir(), ".claude");
    const hooksDir = path.join(claudeDir, "hooks");
    const settingsPath = path.join(claudeDir, "settings.json");
    const hookScriptPath = path.join(hooksDir, HOOK_SCRIPT_NAME);

    // Check if script exists
    if (!fs.existsSync(hookScriptPath)) {
      return false;
    }

    // Check if script version matches (to ensure updates are applied)
    const scriptContent = fs.readFileSync(hookScriptPath, "utf-8");
    const versionMatch = scriptContent.match(/# VERSION: (\d+)/);
    if (!versionMatch || versionMatch[1] !== HOOK_SCRIPT_VERSION) {
      debugLog(`Hook script version mismatch, needs update`);
      return false;
    }

    // Check if settings reference our hook
    if (!fs.existsSync(settingsPath)) {
      return false;
    }

    const content = fs.readFileSync(settingsPath, "utf-8");
    const settings = JSON.parse(content);

    if (!settings.hooks) {
      return false;
    }

    const hooks = settings.hooks as Record<string, unknown>;

    // Check all four hook events
    for (const event of ["SessionStart", "SessionEnd", "PreToolUse", "PostToolUse"]) {
      const eventHooks = hooks[event];
      if (!Array.isArray(eventHooks)) {
        return false;
      }

      // Check if our hook is registered (by command path)
      const hookArray = eventHooks as Array<{ hooks?: Array<{ type?: string; command?: string }> }>;
      const hasOurHook = hookArray.some(
        (h) => h.hooks?.some((inner) => inner.command === hookScriptPath)
      );

      if (!hasOurHook) {
        return false;
      }
    }

    return true;
  } catch {
    return false;
  }
}

